\documentclass[
    a4paper,
    12pt,
    % twocolumn,
    headings=normal
]{article}
    \usepackage{url}
    \usepackage[margin=0.8in]{geometry}
    \usepackage{amssymb}
    \usepackage{enumerate}
    \usepackage{enumitem}
    \usepackage{csquotes}
    \usepackage{graphicx}
    \usepackage{xcolor}
    \usepackage{pdfpages}
    \usepackage{hyperref}
    \usepackage{listings}
    \usepackage{fancybox}
    \usepackage{listings,lstautogobble}    
    \usepackage{titling}
    \usepackage{pdflscape}
    \usepackage[english]{babel}
    \usepackage{csquotes}
    \usepackage{comment}
    \usepackage[normalem]{ulem}
    \usepackage[
    backend=biber,
    style=ieee,
    sorting=ynt
    ]{biblatex}
    \addbibresource{report.bib}
    \usepackage[nottoc,notlot,notlof]{tocbibind}
    \renewcommand\maketitlehooka{\null\mbox{}\vfill}
    \renewcommand\maketitlehookd{\vfill\null}

    \graphicspath{ {Images/} }

    \setlength{\parskip}{\baselineskip}

    \title{Secure Coding Practices:
    \protect\\A General Guideline}
    \author{
        Jay Rovacsek
        \texttt{c3146220@uon.edu.au}\\
    }
    \date{\today}
    \hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=red,
    linktoc=section,
    }
    \pagenumbering{arabic}

    \lstset{frame=tb,
        language=c++,
        aboveskip=2mm,
        belowskip=2mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{blue},
        commentstyle=\color{dkgreen},
        stringstyle=\color{mauve},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=3
    }

    % Default fixed font does not support bold face
    \DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
    \DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

    \definecolor{deepblue}{rgb}{0,0,0.5}
    \definecolor{deepred}{rgb}{0.6,0,0}
    \definecolor{deepgreen}{rgb}{0,0.5,0}

    \begin{document}

    \begin{titlingpage}
        \maketitle
    \end{titlingpage}
    \newpage

    \tableofcontents

    \newpage

    \section{Preface}
    \subsection{Running with Scissors}
        Admittedly, the title for this section is very much thanks to one of the first
        items\cite{Seacord} I read sections of while creating this document. The analogy for 
        development in terms of security could not be more apt for a large portion of the development 
        community.

        Why cover this topic? As a security enthusiast and developer, I often found myself 
        looking at a system left untouched until absolutely required, the design choices, logic and
        knowledge of the language it was written in left with the author. Commonly a requirement 
        for a hotfix was/is needed in a number of this circumstances as a number of critical 
        business services and resources may rely on the system in question.

        A large portion of this paper will focus around the more common exploited vectors of 
        web applications, however the vectors commonly exploited in web application settings are
        commonly exploitable in a desktop application setting, this becomes more and more important 
        to remember as large numbers of commonly used software move to enable cross platform compatibility 
        by utilizing technologies such as Electron\cite{ElectronFramework}.

        Security as a serious concern is only just now becoming much more "mainstream" to companies than 
        it had previously been, movements pushing HTTPS such as Lets Encrypt\cite{LetsEncrypt} or high profile
        individuals such as Troy Hunt\cite{TroyHuntHttpsIsEasy} have aided the process of mitigating 
        some of the most easily exploited vectors such as MiTM attacks on unencrypted communications, a 
        plethora of cybersecurity issues however still remain present in modern organisations, with the 
        potential damage to both organisation and individual such as recent breaches in: Sony\cite{SonyBreach},
        Equifax\cite{EquifaxBreach} and a number of other recent high profile breaches of modern history.

    \subsection{Tripping Over}
        Security in programming \sout{can be a} \textit{is} hard beast to tame. Some languages arguably do much better
        in avoiding issues being caused by users new to the language or unskilled in 
        understanding potential issues with the code they have written.
        We can certainly critique early languages for the level of access to the machine they allow 
        a user, without careful consideration in design and a well founded knowledge in the language 
        used issues notorious of early languages. However, in this day and age of highly abstracted 
        languages and frameworks have we traded old demons for new, or do we really have more safety
        in our computing goals?

        As suggested by Wheeler:\cite{Wheeler} (Page 8)
        \begin{displayquote}
            Many programmers donâ€™t intend to write insecure code - but do anyway.
        \end{displayquote}

    \newpage
    \section{Common Issues in all Languages}
        \subsection{User Input Sanitisation}
            User input sanitisation 

        \subsection{ReDoS}
            Given the requirement for string filtering is extremely common in all applications,
            ReDoS or Regex Denial Of Service\cite{ReDoS} vulnerabilities are a very real threat in application security.
            A number of common defenses can be used against ReDoS attacks, application of 
            which are extremely simple:
            \begin{enumerate}
                \item Atomic grouping in Regex
                \item Regex lifetime limits
                \item Sanitisation of input (Although this defeats the reasons to allow for
                Regex patterns to be used and is very easy to not implement correctly)
            \end{enumerate}

            \subsubsection{Atomic Grouping}
                Atomic grouping in Regex is a group that when Regex is no longer utilising 
                the group is thrown away, and any tokens, or record of the grouping are discarded.
            \subsubsection{Regex Lifetime Limits}
                Lifetime limits are extremely simple in design, a regex process is allowed only 
                a set amount of time in which it can perform its task. Failure to meet this 
                leading to the process being killed.
            \subsubsection{Sanitisation of input}
                This solution to Regex patterns does go very much against the reasoning of 
                using Regex in the first place, but has some valid uses cases:\\
                Consider a user sign-up form on a webpage, the user isn't searching, but 
                using anything but Regex in this setting would be pure nightmare fuel for 
                any developer. A quick search of what patterns to use would yield pages such as
                regular-expressions.info\cite{RegularExpressions.info} and you'd quickly realise
                the rabbit-hole for a suitable Regex statement could be:
                \begin{verbatim}
\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b
                \end{verbatim}

                But just as easily, it could be: 

                \begin{verbatim}
\A(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*
 |  "(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]
      |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])*")
@ (?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
  |  \[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
       (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
          (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]
          |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])+)
     \])\z
                \end{verbatim}
                As suggested by Goyvaerts\cite{RegularExpressions.info}:
                \begin{displayquote}
                    So even when following official standards, there are still trade-offs to be made. Don't blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications.
                \end{displayquote}
                As shown by a simple python script:

                \newcommand\pythonstyle{\lstset{
                    language=Python,
                    basicstyle=\ttm,
                    otherkeywords={self},
                    keywordstyle=\ttb\color{deepblue},
                    emph={
                        __name__,
                        __init__,
                        },
                    emphstyle=\ttb\color{deepred},
                    stringstyle=\color{deepgreen},
                    breaklines=true,
                    breakatwhitespace=false,
                    frame=tb,
                    showstringspaces=false,
                    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
                    }}
                
                    % Python environment
                    \lstnewenvironment{python}[1][]
                    {
                    \pythonstyle
                    \lstset{#1}
                    }
                    {}
                
                    % Python for external files
                    \newcommand\pythonexternal[2][]{{
                        \pythonstyle
                        \lstinputlisting[#1]{#2}}}
            
                \pythonexternal{Resources/regex.py}

                A simple checking of group bounds alone costs almost twice the 
                time to be executed:
                \begin{itemize}
                    \item Simple match: 0.0001652240753173828 seconds
                    \item Complex match: 0.00030231475830078125 seconds
                \end{itemize}

    \newpage
    \section{Modern Language Issues}

    \newpage
    \section{Mature Language Issues}

    \newpage
    \printbibliography

    \end{document}
