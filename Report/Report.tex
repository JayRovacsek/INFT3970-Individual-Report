\documentclass{IEEEtran}
    \usepackage{url}
    \usepackage[margin=0.6in]{geometry}
    \usepackage{float}
    \usepackage{amssymb}
    \usepackage{enumerate}
    \usepackage{enumitem}
    \usepackage{csquotes}
    \usepackage{graphicx}
    \usepackage{xcolor}
    \usepackage{pdfpages}
    \usepackage{hyperref}
    \usepackage{fancybox}
    \usepackage{listings,lstautogobble}    
    \usepackage{titling}
    \usepackage{pdflscape}
    \usepackage[english]{babel}
    \usepackage{comment}
    \usepackage[normalem]{ulem}
    \usepackage[
    backend=biber,
    style=ieee,
    sorting=ynt
    ]{biblatex}
    \addbibresource{report.bib}
    \usepackage[nottoc,notlot,notlof]{tocbibind}
    \renewcommand\maketitlehooka{\null\mbox{}\vfill}
    \renewcommand\maketitlehookd{\vfill\null}

    \graphicspath{ {Images/} }

    \title{Secure Coding Practices:
    \protect\\A General Outline}
    \author{
        Jay Rovacsek
        \texttt{c3146220@uon.edu.au}\\
    }
    \date{\today}
    \hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=red,
    linktoc=section,
    }

    \definecolor{deepblue}{rgb}{0,0,0.5}
    \definecolor{deepred}{rgb}{0.6,0,0}
    \definecolor{deepgreen}{rgb}{0,0.5,0}

    \pagenumbering{arabic}

    \lstdefinestyle{cplusplus}{
        frame=tblr,
        language=c++,
        aboveskip=2mm,
        belowskip=2mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{deepblue},
        stringstyle=\color{deepgreen},
        emphstyle=\color{deepred},
        breaklines=true,
        breakatwhitespace=false,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
        tabsize=3
    }

    \lstdefinestyle{sharpc}{
        language=[Sharp]C,
        aboveskip=2mm,
        belowskip=2mm,
        columns=flexible,
        basicstyle=\small,
        commentstyle=\color{gray},
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{deepblue},
        stringstyle=\color{deepgreen},
        emphstyle=\color{deepred},
        numbers=left,
        breaklines=true,
        breakatwhitespace=false,
        frame=tblr,
        showstringspaces=false,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
        autogobble=true,
        rulecolor=\color{black}
    }

    \lstdefinestyle{golang}{
        language=Go,
        frame=tblr,
        aboveskip=2mm,
        belowskip=2mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{deepblue},
        stringstyle=\color{deepgreen},
        emphstyle=\color{deepred},
        breaklines=true,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
        breakatwhitespace=false,
        tabsize=3
    }

    \lstdefinestyle{python}{
        language=Python,
        frame=tblr,
        aboveskip=2mm,
        belowskip=2mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{deepblue},
        stringstyle=\color{deepgreen},
        emphstyle=\color{deepred},
        breaklines=true,
        postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
        breakatwhitespace=false,
        tabsize=3
    }

    \newcommand\pythonstyle{
        \lstset{style=python}
    }

    % Python for external files
    \newcommand\pythonexternal[2][]{{
        \pythonstyle
        \lstinputlisting[#1]{#2}}}

    % Go environment
    \lstnewenvironment{Python}[1][]
    {
    \pythonstyle
    \lstset{#1}
    }
    {}

    % Go for external files
    \newcommand\gostyleexternal[2][]{{
        \gostyle
        \lstinputlisting[#1]{#2}}}

    % Default fixed font does not support bold face
    \DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
    \DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

    \begin{document}

    \begin{titlingpage}
        \maketitle
    \end{titlingpage}
    \newpage
    \onecolumn

    \tableofcontents

    \newpage
    \twocolumn

    \section{Preface}
    \subsection{Running with Scissors}
        Admittedly, the title for this section is very much thanks to one of the first
        items\cite{Seacord} I read sections of while creating this document. The analogy for 
        development in terms of security could not be more apt for a large portion of the development 
        community.

        Why cover this topic? As a security enthusiast and developer, I often found myself 
        looking at a system left untouched until absolutely required, the design choices, logic and
        knowledge of the language it was written in left with the author. Commonly a requirement 
        for a hotfix was/is needed in a number of this circumstances as a number of critical 
        business services and resources may rely on the system in question.

        A large portion of this paper will focus around the more common exploited vectors of 
        web applications, however the vectors commonly exploited in web application settings are
        commonly exploitable in a desktop application setting, this becomes more and more important 
        to remember as large numbers of commonly used software move to enable cross platform compatibility 
        by utilizing technologies such as Electron\cite{ElectronFramework}.
        That is, not to suggest that the concerns of application security has not been 
        discussed for a number of decades\cite{Booysena1995}

        Security as a serious concern is only just now becoming much more "mainstream" to companies than 
        it had previously been\cite{howard2004building}, movements pushing HTTPS such as Lets Encrypt\cite{LetsEncrypt} or high profile
        individuals such as Troy Hunt\cite{TroyHuntHttpsIsEasy} have aided the process of mitigating 
        some of the most easily exploited vectors such as MiTM attacks on unencrypted communications, a 
        plethora of cybersecurity issues however still remain present in modern organisations, with the 
        potential damage to both organisation and individual\cite{apvrille2005secure} such as recent breaches in: Sony\cite{Sony-Breach},
        Equifax\cite{Equifax-Breach} and a number of other recent high profile breaches of modern history.

    \subsection{Tripping Over}
        Security in programming \sout{can be a} \textit{is} hard beast to tame. Some languages arguably do much better
        in avoiding issues being caused by users new to the language or unskilled in 
        understanding potential issues with the code they have written.
        We can certainly critique early languages for the level of access to the machine they allow 
        a user, without careful consideration in design and a well founded knowledge in the language 
        used issues notorious of early languages. However, in this day and age of highly abstracted 
        languages and frameworks have we traded old demons for new, or do we really have more safety
        in our computing goals?

        As suggested by Wheeler:\cite{Wheeler} (Page 8)
        \begin{displayquote}
            Many programmers donâ€™t intend to write insecure code - but do anyway.
        \end{displayquote}


    \section{What Can Go Wrong?}
        Most developers aren't developers to focus on security, they are creating solutions to 
        problems in order to allow for some benefit to the owner of the software, this could 
        be entertainment, productivity, sales increases or many other reasons.

        But security as a base concept is more important than ever ever due to the nature of
        our increasingly connected world\cite{misovskisecure}. Interestingly enough the attitude I've encountered 
        within a number of development circles could be described as poor at best;
        \begin{displayquote}
            "Security is a block to my creative outlet, security just gets in the way"
        \end{displayquote}
        I won't cite the source of this statement, but I did hear this from a paid software developer
        before and it has stuck with me since.

        \subsection{Recent Prolific Breaches Caused By Poor Development Habits}
            A number of recent breaches can be used as good examples of why this topic is highly 
            important:
            \begin{itemize}
                \item Equifax Breach 2017 (Estimated 143M individuals records leaked)\cite{Equifax-FTC}
                Caused by CVE-2017-5638\cite{CVE-2017-5638} Python POC\cite{POC-CVE-2017-5638}
                \item Yahoo Breach 2014 (Over 500M Accounts Compromised)\cite{Yahoo-Breach} Caused 
                by a mixture of unhashed/salted secrets in DB and using insecure hashing algorithm 
                (MD5) easily broken by multiple toolsets\cite{John-The-Ripper}
                \item Uber Breach 2016 (57M Users and 600,000 Drivers Data Exposed)\cite{Uber-Breach}
                \item Nintendo Switch Jailbreak, uses CVE-2016-4657\cite{CVE-2016-4657} to 
                execute arbitrary code\cite{POC-CVE-2016-4657}.
                
            \end{itemize}

    \section{Common Issues in most Languages}
        \subsection{Injection}
            No wide-spread languages in use currently offer an 'out of the box' level of 
            protection against maliciously crafted input by users, generally these issues are 
            mitigated or defended against decently by developers; input usually will have some level
            of constraint on the data.
            This however isn't to say that there are better methods to handling user input.
            \\
            Methods of defense will generally point to either parametrization or limitation of scope 
            with the input data.

            \subsubsection{Attack Vectors}
                SQL will generally be the best example of this issue, legacy systems will not have 
                the ability to use APIs offered by the language the program was written in or 
                have attempts custom written by the original author that could have missed some 
                potential vectors.
                \\
                Consider the following:

                \lstset{style=sharpc}
                \begin{lstlisting}
                    String query = "SELECT * FROM Login WHERE loginId='" + request.getParameter("id") + "'";
                \end{lstlisting}

                With this given code, an attacker can easily suggest their username is:
                ' or '1'='1. which in this case should return all user accounts 
                irrespective of if the user has access or not to this data.

            \subsubsection{Prevention}
                Prevention as suggested above is trivial, some, many or best of all, all 
                of the following suggestions would be recommended:
                \begin{itemize}
                    \item Validation of Input (Can be fallible in a number of cases)
                    \item Parametrization of all non-trusted zones, even better of all
                    zones.
                    \item Use of Stored Procedures
                    \item Limitation of return data in queries.
                \end{itemize}



        \newpage
        \subsection{ReDoS / Regex Denial Of Service}
            Given the requirement for string filtering is extremely common in all applications,
            ReDoS or Regex Denial Of Service\cite{ReDoS} vulnerabilities are a very real threat in application security.
            A number of common defenses can be used against ReDoS attacks, application of 
            which are extremely simple:
            \begin{enumerate}
                \item Atomic grouping in Regex
                \item Regex lifetime limits
                \item Sanitisation of input (Although this defeats the reasons to allow for
                Regex patterns to be used and is very easy to not implement correctly)
            \end{enumerate}

            \subsubsection{Atomic Grouping}
                Atomic grouping in Regex is a group that when Regex is no longer utilising 
                the group is thrown away, and any tokens, or record of the grouping are discarded.
            \subsubsection{Regex Lifetime Limits}
                Lifetime limits are extremely simple in design, a regex process is allowed only 
                a set amount of time in which it can perform its task. Failure to meet this 
                leading to the process being killed.
            \subsubsection{Sanitisation of input}
                This solution to Regex patterns does go very much against the reasoning of 
                using Regex in the first place, but has some valid uses cases:\\
                Consider a user sign-up form on a webpage, the user isn't searching, but 
                using anything but Regex in this setting would be pure nightmare fuel for 
                any developer. A quick search of what patterns to use would yield pages such as
                regular-expressions.info\cite{RegularExpressions.info} and you'd quickly realise
                the rabbit-hole for a suitable Regex statement could be:

                \begin{verbatim}
\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b
                \end{verbatim}

                But just as easily, it could be: 

                \begin{verbatim}
\A(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*
 |  "(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]
      |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])*")
@ (?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
  |  \[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}
       (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
          (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]
          |  \\[\x01-\x09\x0b\x0c\x0e-\x7f])+)
     \])\z
                \end{verbatim}
                As suggested by Goyvaerts\cite{RegularExpressions.info}:
                \begin{displayquote}
                    "So even when following official standards, there are still trade-offs to be made. Don't blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications."
                \end{displayquote}

                As shown by a \hyperref[sec:PyReDoS]{\color{blue}simple python script} the checking of 
                group bounds alone costs almost twice the time to be executed and realistically 
                does not give the application any more weight in being more accurate.
                \begin{table}[H]
                    \centering
                    \begin{tabular}{|l|l|}
                    \hline
                                  & Time Taken (Seconds)   \\ \hline
                    Simple Match  & 0.0001652240753173828  \\ \hline
                    Complex Match & 0.00030231475830078125 \\ \hline
                    \end{tabular}
                    \end{table}

    \newpage
    \section{Modern Language Issues}

    \newpage
    \section{Mature Language Issues}

    \newpage
    \printbibliography

    \newpage
    \onecolumn
    \appendix
    \section{Appendix}
        \subsection{Proof Of Concept Code}
            \subsubsection{Python ReDoS}
            \label{sec:PyReDoS}
            \_
            \medskip
                \pythonexternal{Resources/regex.py}

    \end{document}
